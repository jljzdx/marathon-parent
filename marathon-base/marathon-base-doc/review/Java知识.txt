1、Java基础
|-NIO与BIO区别（看图marathon-base-doc/java/BIO.png、NIO.png）
  |--NIO非阻塞式IO多路复用；BIO阻塞
  |--NIO面向缓冲区，可以双向读写；BIO面向流，只能单向读写，出去从输出流通道走，回来从输入流通道走
  |--BIO 好比是通道传输，一来一回；NIO 好比是管道传输，一堆来一堆回
  |--BIO 和 NIO 作为 Server 端，当建立了 10 个连接时，分别产生多少个线程？10、1
  |--应用：Netty组件就是对NIO的包装，Dubbo就是使用Netty
|-缓存和缓冲的区别
  |--缓存：把常用数据保存在内存的缓存区中（用来加速读取）
  |--缓冲：在向硬盘写入数据时，先把数据放入缓冲区，然后再一起向硬盘写入，减少io操作次数，提高效率（类似生活中的垃圾桶和垃圾站）（用来加速写入）
|-HashMap原理
  |--采用位桶+链表+红黑树实现（也叫平衡二叉树：当插入一个结点时，如果破坏了树的平衡性，找出最小不平衡树，通过旋转，调整成新的平衡二叉树）
  |--在HashMap中有两个很重要的参数，容量(Capacity：16)和负载因子(LoadFactor：0.75)
  |--链表的长度大于8时，采用红黑树(TreeMap)，提高查找效率（因为如果最坏的情况所有的Node都落在一个桶中，这样hashmap就退化成了一个链表——查找时间从O(1)到O(n)，使用红黑树查找时间O(logn)）
  |--哈希碰撞:就是hash(key)相等，然后使用链表解决
  |--put
     |---通过table%hash(key)得到数组index。
     |---判断index位置有没有节点，如果没有直接添加节点，如果有，判断key是否相等，如果相等，直接覆盖，如果不想等，判断是链表还是红黑树，如果是链表，判断长度是否>8，如果>8，采用红黑树
     |---判断元素个数时候大于Capacity*loadFactor，如果大于就扩容
  |--resize
     |---先创建一个长度为原来2倍的新table，然后通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计算HashMap的扩容阀值
  |--get
     |---1、通过key的hash找到数组的位置
     |---2、直接判断是不是第一个节点-》判断是不是树节点-》否则就是链表
  |--JDK1.8 ConcurrentHashMap与HashMap很相似，抛弃Segment分段锁，而采用了CAS算法 + synchronized来保证并发安全性
  |--JDK1.7 HashTable与ConcurrentHashMap最大的区别：HashTable这个表就一个锁；ConcurrentHashMap采用锁分段技术，默认16个锁
  |--JDK1.7 ConcurrentHashMap二次hash带来的问题是整个hash的过程比hashmap单次hash要长
    HashMap:
    |-数组+单向链表+红黑树
    |-键值允许为null
    |-线程不安全
    |-默认的初始大小为16,扩容2n
    HashTable:
    |-数组+单向链表
    |-键值不允许为null
    |-线程安全
    |-默认的初始大小为11,扩容2n+1
    ConcurrentHashMap:Segment[]->HashEntry[]
    |-数组+单向链表+红黑树
    |-键值不允许为null
    |-线程安全
    |-默认的初始大小为16,扩容2n
    |-ConcurrentHashMap不会抛出ConcurrentModificationException
    线程安全的Map：
    |-Map<String, String> hashtable = new Hashtable<String, String>();
    |-Map<String, String> synchronizedHashMap = Collections.synchronizedMap(new HashMap<String, String>());
    |-Map<String, String> concurrentHashMap = new ConcurrentHashMap<String, String>();
|-fock join：将一个大的任务拆分成多个子任务，自己的任务完成后，会窃取任务来执行【工作窃取】。
  |--两种类型：有返回结果（RecursiveTask）和无返回结果（RecursiveAction）
  |--例子：用最快的速度完成(1+...+100000)
  |--每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务）
|-volatile：保证下一个读取操作会在前一个写操作之后发生。
  |--它处理不了【i++或if (flag) {flag = false;}】这种不具备原子性操作。
  |--可以使用AtomicBoolean\AtomicInteger\AtomicLong来保证原子性
     private static AtomicBoolean mAtomicFlag = new AtomicBoolean(true);
  |--保证成员变量的可见性，禁止指令重排序，但不能保证操作的原子性。
  |--让变量每次在使用的时候，都从主内存中取，而不是从各个线程的“工作内存”。
  |--当线程对共享变量修改时，会导致线程1的工作内存中缓存变量的缓存行无效，所以线程1只能再去主内存读取
  |--例子：
  public class Demo { public int counter = 0;}
  线程1：counter = 7;
  线程2：counter = 0;这时7还没有更新到主内存中，导致线程2还在使用之前的值0。
|-ThreadLocal(线程局部变量)：在不同的 Thread 中有不同的副本，保证各个线程之间的变量互相隔离、相互独立
  |--private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>();
  |--1、每个线程需要有自己单独的实例；2、实例需要在多个方法中共享，但不希望被多线程共享
  |--原理：
     |---维护了一个ThreadLocalMap，使用ThreadLocal<T>的弱引用（弱引用对象在Java虚拟机进行垃圾回收时，就会被释放）作为Key，T作为value。
         使用弱引用的原因在于，下一次垃圾回收的时候必然会被清理掉
  |--内存泄露：因为key是弱饮用，很容易被清理掉，这样就会存在key=null的value，手动调用remove()
  |--初始化赋值
  private static final ThreadLocal<SimpleDateFormat> SDF = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      }
  };
  Java8的写法：
  private static final ThreadLocal<SimpleDateFormat> SDF = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
|-抽象类和接口的区别：
    1、成员区别：
    |-抽象类：
      |--成员变量：变量、常量
      |--构造方法：有
      |--成员方法：抽象、非抽象
    |-接口：
      |--成员变量：常量
      |--构造方法：无
      |--成员方法：抽象
    2、关系区别：
    |-类与类：单继承
    |-类与接口：单实现、多实现
    |-接口与接口：多继承
    3、设计理念：
    抽象类：体现的是"is a"的关系，定义的是共性功能
    接口：体现的是"like a"的关系，定义的是扩展功能
|-Lock和synchronized区别：
  |--Lock不会自动释放锁；synchronized会自动释放锁;
  |--Lock是一个接口，而synchronized是Java中的关键字
  |--Lock可以让等待锁的线程响应中断，而synchronized却不行
  |--Lock可以知道有没有成功获取锁，而synchronized却无法办到
  |--使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生
  |--锁概念：
     |---可重入锁（Lock、synchronized）：例如当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，不必重新去申请锁。
     |---可中断锁（Lock）：如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
     |---公平锁（Lock可以设置成公平锁，ReentrantLock lock = new ReentrantLock(true);）：以请求锁的顺序来获取锁，等待时间最久的线程（最先请求的线程）会获得该锁。
     |---读写锁（ReentrantReadWriteLock）：1、获得读锁后，其它线程可获得读锁而不能获取写锁；2、获得写锁后，其它线程既不能获得读锁也不能获得写锁。
|-如何控制多个线程执行顺序
  |--join();
  |--SingleThreadExecutor
  |--信号量Semaphore
|-线程池
  |--新任务进入时线程池的执行策略：
     |---1、如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。
     |---2、如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。
     |---3、如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。
     |---举例：counts是同时启动的线程数。
     counts <= corePoolSize：所有的任务均为核心线程执行，没有任何 Runnable 被添加到 workQueue中
     corePoolSize < counts <= corePoolSize + workQueue.size()：所有任务均为核心线程执行，当核心线程处于繁忙状态，则将任务添加到 workQueue 中等待
     corePoolSize + workQueue.size() < counts <= maximumPoolSize + workQueue.size()：corePoolSize 个线程由核心线程执行，超出队列长度 workQueue.size() 的任务，将另启动非核心线程执行
     counts > maximumPoolSize + workQueue.size()：将会报异常
  |--几个重要参数：
     |---corePoolSize：核心线程数量，线程池维护线程的最少数量
         用于设定 thread pool 需要时刻保持的最小core threads的数量，即便这些core threads处于空闲状态啥事都不做也不会将它们回收掉
     |---maximumPoolSize：线程池维护线程的最大数量，放到队列的不算
     |---keepAliveTime：线程池中非核心线程空闲的存活时间大小，超过该时间的空闲线程会被销毁
         默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用
     |---workQueue：线程池所使用的任务缓冲队列
     |---handler：线程池对拒绝任务的处理策略
  |--丢弃策略：
     |---AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常
     |---DiscardPolicy：丢弃任务，但是不抛出异常
     |---DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试提交任务
     |---CallerRunsPolicy：由调用线程处理该任务，重试添加当前的任务，他会自动重复调用execute()方法
     |---可以通过实现RejectedExecutionHandler接口自定义处理方式
  |--队列
     |---有界队列（ArrayBlockingQueue）：容量固定的有界阻塞队列
     |---同步移交（SynchronousQueue）：不希望任务在队列中等待而是希望将任务直接移交给工作线程
     |---无界队列（LinkedBlockingQueue）：newFixedThreadPool
     |---延迟队列（DelayQueue）：newScheduledThreadPool
     |---优先级队列（PriorityBlockingQueue）：newCachedThreadPool
  |--五个线程池
     |---FixedThreadPool：固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
         ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
         public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
                 return new ThreadPoolExecutor(nThreads, nThreads,
                                               0L, TimeUnit.MILLISECONDS,
                                               new LinkedBlockingQueue<Runnable>(),
                                               threadFactory);
             }
     |---CachedThreadPool：可缓存线程池，用于并发执行大量短期的小任务。
         ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
     |---SingleThreadPool：单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的（按照任务的提交顺序执行）。
         ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
     |---ScheduledThreadpool：大小无限制的线程池，支持定时及周期性任务执行。
         ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
     |---WorkStealingPool：JDK8引入,具有抢占式（窃取）操作的线程池，并行，适合使用在很耗时的操作
         ExecutorService workStealingPool = Executors.newWorkStealingPool();
|-强引用、软引用、弱引用、虚引用的区别？
  |--强引用：Object obj = new Object();
  |--软引用：当内存空间足够，垃圾回收器就不会回收它，当内存空间不足了，就会回收这些对象的内存
            SoftReference<String> softRef=new SoftReference<String>(str);
  |--弱引用：发生GC时，如果发现了弱引用对象，不管内存空间是否足够，都会回收它的内存
            WeakReference<String> abcWeakRef = new WeakReference<String>(str);
  |--虚引用：任何时候都可能被垃圾收集器回收（比如obj=null）
2、设计模式
|-动态代理模式：
  |--JDK:拦截器（InvocationHanlder）+反射机制生成一个实现代理接口的匿名类
  |--Cglib:利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
  |--SpringCloud中的Feign也是使用JDK动态代理实现的
  |--Mybatis：UserMapper mapper = session.getMapper(UserMapper.class);
  |--Spring AOP使用哪种代理模式：
     |---如果目标对象实现了接口，默认情况下会采用JDK动态代理；当然也可以通过配置使用Cglib动态代理（<aop:aspectj-autoproxy proxy-target-class="true"/>）。
     |---如果目标对象没有实现了接口，必须采用CGLIB动态代理。
|-适配器模式：
  |--场景：你定义类一个接口，我也定义了一个接口，我们都不想改，这时就可以写一个适配器来适配这两个接口
  |--类适配器：使用继承的方式，看ClassAdapter类就懂了
  |--对象适配器：看ObjectAdapter类就懂了，扩展性好，子类也可以被适配
|-装饰器模式：
  |--为什么使用：动态地给一个对象添加一些额外的职责。一般的，我们为了扩展一个类经常使用继承方式实现，并且随着扩展功能的增多，子类会很膨胀。
     装饰器模式相比生成子类更为灵活，简单的总结（不改变原类文件、不使用继承、动态扩展）。
  |--类的继承的缺点 ( 高耦合，会产生更多的子类，从而引起类的爆炸 )
  |--mybatis二级缓存就是使用装饰模式的例子
  |--项目实战：
     |---需求：采用sls服务监控项目日志，以Json的格式解析，所以需要将项目中的日志封装成json格式再打印。
         现有的日志体系采用了log4j + slf4j框架搭建而成。调用起来是这样的:
         private static final Logger logger = LoggerFactory.getLogger(Component.class);
         logger.error(string);
     |---这样打印出来的是毫无规范的一行行字符串。在考虑将其转换成json格式时，我采用了装饰器模式。
     |---具体实现：
         public class DecoratorLogger implements Logger{
            public Logger logger;
            public DecoratorLogger(Logger logger) {
                this.logger = logger;
            }
             @Override
             public void error(String str) {}

             @Override
             public void info(String str) {}
         }
         public class JsonLogger extends DecoratorLogger{
            public JsonLogger(Logger logger) {
                super(logger);
            }
            @Override
            public void info(String msg) {
                JSONObject result = composeBasicJsonResult();
                result.put("MESSAGE", msg);
                logger.info(result.toString());
            }
            @Override
            public void error(String msg) {
                JSONObject result = composeBasicJsonResult();
                result.put("MESSAGE", msg);
                logger.error(result.toString());
            }
            public void error(Exception e) {
                JSONObject result = composeBasicJsonResult();
                result.put("EXCEPTION", e.getClass().getName());
                String exceptionStackTrace = ExceptionUtils.getStackTrace(e);
                result.put("STACKTRACE", exceptionStackTrace);
                logger.error(result.toString());
            }
            public static class JsonLoggerFactory {
                @SuppressWarnings("rawtypes")
                public static JsonLogger getLogger(Class clazz) {
                    Logger logger = LoggerFactory.getLogger(clazz);
                    return new JsonLogger(logger);
                }
            }
         }
     |---最终调用：
         private static final Logger logger = JsonLoggerFactory.getLogger(Component.class);
         logger.error(string);
|-构造者模式：
  |--用来解决构造函数不便，复杂对象的构建
  |--将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。一些基本部件不会变，而其组合经常变化的时候。以手机和零件为例。
  |--与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
|-观察者模式
  |--一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知
|-门面模式
  |--比如：张三（客户端）想建房子，本来需要自己去找会和泥的、会搬砖的、会砌墙的（这三个叫子系统），但现在有了包工头（门面角色），张三直接找包工头，包工头去做所有的事情。
|-模板模式
  |--一些方法通用，却在每一个子类都重新写了这一方法，比如：【下单、吃面、付钱；下单、吃烧烤、付钱】
|-工厂模式：
  |--
|-单例模式：
  |--双检锁：
  public class Singleton {
      private static volatile Singleton instance = null;
      private Singleton() { }
      public static Singleton getInstance() {
          if (instance == null) {
              synchronized(Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  |--枚举：让JVM来帮我们保证线程安全
  public enum Singleton {
      INSTANCE;
      public void doSomething() {
          System.out.println("doSomething");
      }
  }

3、JVM
|-面试问CPU100%怎么排查
  |--查消耗cpu最高的进程号PID
     |---top –c
     |---键入P (大写p)，进程按照CPU使用率排序
  |--根据PID查出消耗cpu最高的线程号，并转成16进制
     |---top -Hp 17376
     |---printf '%xn' 17378 17379 17412 17426
  |--导出进程快照：jstack 17376【进程PID】 > yao.stack
  |--分析快照，定位到具体代码：cat -n yao.dump | grep -A10【显示后续10行】 '0x4404'
|-StackOverflowError
  |--栈深度大于虚拟机所能提供的深度，会抛出StackOverflowError，比如递归
|-OutOfMemoryError
  |--一般是因为大对象产生的
  |--项目中怎么解决这种问题？
     |---查看错误日志
     |---检查对数据库查询中，是否有一次获得全部数据的查询。
     |---是否有死循环或递归调用
     |---检查List、MAP等集合对象是否有使用完后，未清除的问题
     |---使用内存查看工具（jconsole、jvisualvm）动态查看内存使用情况
         |----生成堆快照（dump）：-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/Users/microbin/Downloads/test.dump  -XX:+PrintGCDetails -Xms14m -Xmx34m
         |----使用工具打开test.dump
         |----找到大对象
  |--创建的对象太多，可能是死循环，导致超过堆内存大小（可设置参数Xms（初始堆大小）和Xmx（最大堆大小））
  |--线程创建太多
参数调优：
|-调优就是减少full GC，因为STW【stop the world】,会停止掉所有用户线程。
|-设置使用哪种收集器：-XX:+UseConcMarkSweepGC -XX:-UseParNewGC 新生代：Serial；老年代：CMS
|-查看使用哪种收集器：java -XX:+PrintCommandLineFlags -version -> java -XX:+PrintGCDetails -version
|-常用参数：【注意：+是启用；-是关闭】
  |-- -Xms20m:堆初始值20M 、 -Xmx20m:堆最大可用值20M【这两个参数一般设置成一样】
  |-- -Xss256k:每个线程的栈大小
  |-- -XX:ParallelGCThreads=n:并行垃圾收集时，使用的线程数
  |-- -XX:+UseAdaptiveSizePolicy:打开自适应GC策略
  |-- -XX:NewRatio=3:设置年轻代和年老代的比值；年轻代与年老代比值为1：3
  |-- -XX:MaxTenuringThreshold=0:年轻代对象不经过Survivor区
  |-- -XX:SurvivorRatio=3:年轻代中Eden区与两个Survivor区的比值；Eden：Survivor=3：2
  |-- -XX:MaxMetaspaceSize=20:配置元空间最大内存20M
|-例子：java -Xms20m -Xmx20m -XX:+UseAdaptiveSizePolicy -XX:SurvivorRatio=4 -XX:NewRatio=3 -XX:MaxMetaspaceSize=20 -XX:+UseConcMarkSweepGC -XX:-UseParNewGC -XX:+PrintGCDetails
JVM内存结构【hotspot jvm】：
|-程序计数器【PC寄存器】：记录着当前线程所执行的字节码的行号（说白了，就是线程执行过程中突然挂起，当抢到资源需要知道之前执行到哪个位置了）
  |--每个线程工作时都有属于自己的独立计数器
  |--执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址
  |--执行native本地方法时，程序计数器的值为空
|-Java栈：栈帧组成，每个栈帧对应一个被调用的方法
  |--内存逃逸：指方法中new的对象，原本是在栈帧分配空间【又叫做栈上分配】，后来由于别的地方需要引用方法中的对象或者创建的是大对象，导致对象被分配到堆中。
  |--局部变量表：存储方法参数变量
  |--操作数栈：程序中的所有计算过程都是在借助于操作数栈来完成的
  |--动态连接：指向当前方法所属的类的运行时常量池的引用
  |--方法出口：方法执行完毕之后，要返回之前调用它的地方，出栈
  |--一些额外的附加信息
|-堆：存储对象以及数组，JDK7和JDK8不同之处在于堆【JDK6永久带；JDK7堆（JDK6永久带中的部分数据转移到了heap中，如：字面量、符号引用、类的静态变量，但永久代仍存在）；
      JDK8移除永久带，使用直接内存（又叫元空间）直接从操作系统中分配】
|-方法区【JDK8叫元空间】：class对象（包括类的名称、方法信息、字段信息）、静态变量、常量（final修饰的）
|-JDK7、JDK8字符串常量池移到堆中
|-变量存储位置：
  |--成员变量：
     |---静态：存储在方法区的静态区
     |---非静态：存储在堆中
     |---String a = "A";：a存储在堆中，"A"存储在方法区的常量池
  |--局部变量：
     |---String a = new String("A");：a存储在栈中，new String存储中堆中，"A"存储在方法区的常量池
GC:
|-minor gc（Eden）、young gc（Eden+Survivor）、major gc（Old）、full gc（New+Old）
  |--full GC一般是因为元空间不足或者老年代空间不足
|-什么时候被移动到年老代呢？
  |--大对象直接进入老年代
  |--Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时
     （默认-XX:MaxTenuringThreshold=15岁，Parallel Scavenge中默认值为15，CMS中默认值为6，G1中默认值为15），就会被移动到年老代中
  |--当Eden+From/To要移动到From/To时，如果存活的对象大于From/To的一半空间，就会使用老年代的担保机制复制一部分对象到老年代。
|-判断哪些内存需要被回收
  |--引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收
  |--可达性分析法：当一个对象到GC Roots没有任何引用链（强、软、弱、虚）相连时，则证明此对象是不可用的
     |---可作为GC Roots：虚拟机栈、方法区的类静态属性、方法区中的常量、本地方法栈
|-垃圾收集算法
  |--标记-清除算法：效率和空间不足，会产生大量不连续的内存碎片，导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
  |--复制算法：因为Eden区的对象大部分都会“朝生暮死”，所以使用复制算法效率高
     1、当eden区没有足够空间的时候，触发第一次 ygc,把活着的对象拷贝到 from 区，并将其年龄设为1，当 eden 区再次没有足够空间的时候，
     触发 ygc 时，会扫描 eden和 from，对其进行垃圾回收，存活对象直接复制到 to 区域，年龄加1，并将 eden和 from区清空
     2、当后续 eden 区发生 ygc时，会对 eden和to区进行垃圾回收，存活对象复制到 from 区，并将 eden和 to 区域清空
     3、存活对象会在from 和 to 区复制来复制去，年龄达到15岁如果还存活，直接存入老年代
     4、如果survivor的from/to区没有足够的内存存放存活的对象，则使用老年代的担保机制复制一部分对象到老年代。
  |--标记-整理算法：不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
  |--分代收集算法：大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法
|-垃圾收集器【现在基本上都是使用组合收集器：如JDK7默认使用：Parallel Scavenge+Parallel Old】
  |--Serial收集器：【新生代】
      |---是一个采用复制算法的单线程的收集器，会暂停所有用户线程。
  |--ParNew收集器：【新生代，Java8已弃用，Java9已删除】
     |---其实就是Serial收集器的多线程版本，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
	 |---适用于多CPU的环境中，新生代并行（ParNew），老年代串行（Serial Old）
  |--Parallel Scavenge收集器：【新生代】
     |---也是用复制算法的收集器，也是并行的多线程收集器，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。
	 |---与ParNew收集器最重要的一个区别：GC自适应调节策略
     |---GC自适应调节策略：它有一个-XX:+UseAdaptiveSizePolicy参数，用来打开自适应调节策略，就不需要手动指定新生代大小、Eden区和Survivor参数等参数了，
         虚拟机会根据当前系统的运行情况，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
  |--Serial Old收集器：【老生代】
     |---是一个使用“标记-整理”算法的单线程收集器，会暂停所有用户线程。
  |--Parallel Old收集器：【老生代】
     |---使用多线程和“标记-整理”算法
  |--CMS收集器：【老生代】
     |---以最小的停顿时间为目标的收集器，基于标记 - 清除算法，并发收集、低停顿，可结合Serial、ParNew使用。
     |---缺点：对CPU资源非常敏感【主要是因为并发标记和并发清除阶段】、无法处理浮动垃圾【在重新标记期间，之前已经标记的对象可能变成垃圾了】、产生大量碎片
     |---注意：不会等到老年代占满的时候才去回收，默认占到92%才去回收
     |---包括四个步骤：
	     |----初始标记
	          |-----需要STW
	          |-----标记老年代中所有存活的GC Roots对象
	     |----并发标记
	          |-----不需要STW
	          |-----标记老年代中所有存活的GC Roots对象下关联的对象。
	     |----重新标记
	          |-----需要STW
	          |-----标记年轻代中活着的对象引用到的老年代的对象、标记刚刚从年轻代移动到老年代的对象【为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，需要STW】
	     |----并发清除【回收所有的垃圾对象】
	 |---参数配置：-XX:+UseConcMarkSweepGC
  |--G1收集器：【整堆收集器，也就是单独使用在新生代和老年代】
     |---为解决CMS算法产生空间碎片（标记整理算法）和可预测垃圾回收的停顿时间
	 |---G1的新生代收集跟ParNew类似；G1的老年代收集跟CMS类似
     |---参数配置：-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200【最大暂停时间】
	 |---取消了新生代，老年代的物理空间划分，但还保留有新生代和老年代的概念
	 |---G1算法将堆划分为若干个区域（Eden、Survivor、Old、Humongous），它仍然属于分代收集器。
	 |---G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了
	 |---G1划分了一个Humongous（巨大的）区，它用来专门存放巨型对象。
	 |---young gc：触发机制和之前的young gc差不多
	 |---mixed gc：除了回收整个young region，还会回收一部分的old region。当老年代大小占整个堆大小百分比达到该阈值（-XX:InitiatingHeapOccupancyPercent）时，会触发一次mixed gc。mixed gc的执行过程有点类似cms
	 |---full gc：当老年代没有足够空间分配时，会出发一次full gc
|-JDK默认垃圾收集器【查看JDK使用哪种收集器：java -XX:+PrintCommandLineFlags -version】
  |--jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
  |--jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
  |--jdk1.9——jdk11 默认垃圾收集器G1

类加载:
|-类加载过程
  |--加载：找到类的字节码文件，利用类加载器创建一个Class对象
  |--连接：
     |---验证：验证加载的类信息符合JVM规范
	 |---准备：为静态变量分配内存，并设置默认初始值
	     |----public static int value = 123;赋给value的值是0
	     |----public static final int value = 123;赋给value的值是123
	 |---解析：将常量池的符号引用替换为直接引用
	 class Worker{
         ......
         public void gotoWork(){
             car.run(); //这段代码在Worker类中的二进制表示为符号引用
         }
         ......
     }
  |--初始化：主要是对静态变量进行初始化
|-类变量指定初始值有两种：
  |--声明类变量时指定初始值
  |--使用静态代码块指定初始值
|-初始化步骤
  |--如果该类还没有被加载和连接，则先加载并连接该类
  |--如果该类的直接父类还没有被初始化，则先初始化其直接父类。所以JVM最先初始化的总是Object类
  |--如果类中有初始化语句，则系统依次执行这些初始化语句
|-初始化时机
  |--创建类的实例，new Person();
  |--调用类的静态方法
  |--访问类的静态变量
  |--反射创建类Class.forName("");
  |--初始化某个类的子类，触发父类初始化
  |--main方法
  |--特例：
     class Test{
		static{
			System.out.println("Test 静态代码块");//这句不会被打印
		}
		static final String json = "json string";//json被称为”宏变量“
		public static void main(String[] args){
			System.out.println(Test.json);//在编译时，Test.json就已经被替换成"json string"了，所以不会导致初始化Test类
		}
	 }
     class Test{
		static{
			System.out.println("Test 静态代码块");//这句会被打印
		}
		static final String json = System.currentTimeMillis()+"";
		public static void main(String[] args){
			System.out.println(Test.json);//在编译时，Test.json还不能确定下来，所以会导致初始化Test类
		}
	 }
     public class ClassTest{
		public static void main(String[] args){
			ClassLoader cl = ClassLoader.getSystemClassLoader();
			cl.loadClass("Test");//不会导致初始化Test类
			Class.forName("Test");//会导致初始化Test类
		}
	 }
|-类加载器
  |--Bootstrap ClassLoader：启动类加载器（负责加载%JAVA_HOME%/lib路径中的核心类库）
  |--Extension ClassLoader：扩展类加载器（负责加载%JAVA_HOME%/lib/ext路径中的类库）
  |--Application ClassLoader：应用程序类加载器（负责加载classpath下的类库）
  |--自定义类加载器：
     |---extends ClassLoader:loadClass(String name, boolean resolve);findClass(String name);
     |---什么场景？
|-类加载机制
  |--双亲委派模型：
     |---如果一个类加载器收到类加载的请求，先判断类是否已经被加载过，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。
         每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
	 |---为什么需要双亲委派模型？
	 黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。
	 比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。
	 并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，
	 那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。
	 而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。
	 或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?
	 确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。
  |--如何打破双亲委派模型？
     |---比如JDBC通过Thread.currentThread().getContextClassLoader()得到线程上下文加载器来加载Driver实现类

4、Java8函数式接口
|-常用的函数式接口：
  |--Supplier 功能性接口，有一个get方法，没有参数,例子：实现SessionFactory创建
  Supplier<SessionFactory> s = () -> {  return new SessionFactory();};
  SessionFactory sessionFactory = s.get();
  |--Consumer 消费性接口，有一个accept方法，无返回值，例子：实现集合遍历操作，看ConsumerTest类
  |--Function  功能性接口，有一个apply方法，例子：实现用户密码 Base64加密
  Function<String,String> f01=(password)->Base64.getEncoder().encodeToString(password.getBytes());
  System.out.println(f01.apply("123456"));//输出加密后的字符串
  |--Predicate 断言性接口，有一个test方法，返回boolean，例子：实现字符串判空操作
  Predicate<String> p01=(str)->str.isEmpty()||str.trim().isEmpty();
  System.out.println(p01.test(""));
|-自定义函数时接口
  |--有且仅有一个抽象方法的接口，但是可以有多个非抽象方法的接口
  |--举例：
  @FunctionalInterface
  public interface MyFunction<A,B,C> {
    C Do(A a,B b);
  }
  测试：
  MyFunction fun = (a,b) -> (int) a+ (int)b;
  System.out.println(fun.Do(1,2));
|-默认方法
  |--允许接口包含带实现的方法
  |--在接口中定义默认方法：default String forEach(){ System.out.print(); }
  |--用来解决一个问题：
     如果Collection接口添加了新的方法，例如forEach，那么每个实现了Collection接口的自定义类就必须实现该方法，不符合逻辑。
     所以使用默认方法来解决。
5、学习渠道
|-芋道源码（博客）、美团技术（公众号）、知识星球、博客园、github、付费群、腾讯视频课程

6、基本数据类型
byte、short、int、long、double、float、char、boolean
7、int和Integer的区别
|-int是基本数据类型，Integer是int的包装类
|-int的默认值是0，Integer默认值是null
|-自动拆箱装箱
  |--Integer integer=1; //装箱   int i=integer; //拆箱
  |--反编译结果：Integer integer=Integer.valueOf(1);int i=integer.intValue();
8、String
String是线程安全的，因为是final修饰的类，不可变的
9、==和equals的区别
==：是一个运算符，对于基本数据类型比较的是变量的值；对于对象类型，比较的是对象的地址
equals：是Object的方法，比较两个对象内容是否相等，默认比较的也是地址，源码如下：
public boolean equals(Object obj) {
    return (this == obj);
}
hashCode():
hashCode()是一个native方法，为对象产生整型的hash值,用作对象的唯一标识；
两个对象的equals()相等，hashCode()必须相等，反之，hashCode()不一定相等，因为存在hash冲突
10、synchronized和Lock区别
|-synchronized是Java关键字；Lock是java.util.concurrent.Locks 包下的一个接口
|-synchronized自动释放锁；Lock需要在finally块中手动释放
|-synchronized不能响应中断；Lock可响应中断
|-synchronized是非公平锁；Lock既可以为公平锁，又可以为非公平锁
|-底层实现：synchronznized映射成字节码指令就是增加两个指令：monitorenter、monitorexit；Lock底层则基于volatile和cas实现
11、线程的生命周期
看图：线程的生命周期.png
12、异常
看图：java异常层次结构图.png



