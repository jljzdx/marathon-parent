1、网络协议：
|-7层协议：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层
|-IP协议属于网络层、TCP属于传输层、HTTP属于应用层
|-socket是对TCP/IP协议的封装，不是协议，只不过是一个API
|-TCP是基于IP的，HTTP是基于TCP的
|-三次握手？
  |--浏览器（192.168.2.33）向服务器（220.181.50.118）发出连接请求
  |--服务器（220.181.50.118）回应了浏览器（192.168.2.33）的请求，并要求确认
  |--浏览器（192.168.2.33）回应了服务器（220.181.50.118）的确认，连接成功
|-TCP和UDP的区别？
  |--TCP面向连接，三次握手，所以是可靠传输；UDP是无连接的，所以不能保证可靠
  |--TCP是点对点；UDP支持一对一，一对多，多对一和多对多的交互通信
  |--TCP首部开销大20字节，UDP首部开销小8字节
  |--TCP面向字节流传输；UDP面向报文传输

2、http和https的区别：
|-http不安全，https安全
|-http默认端口80，https默认端口443
|-http属于应用层协议，https属于传输层协议
|-HTTPS 需要CA机构颁发的SSL证书，一般免费证书较少，因而需要一定费用
https的原理：
|-Client端发送https请求
|-Server端使用SSL安全认证传输，返回证书和公钥给Client端
|-Client端生成一个随机数作为对称加密的密钥，然后使用公钥加密随机数传给Server端
|-Server端使用私钥解密得到随机数（密钥），然后使用该密钥加密数据返回给Client端
|-Client端使用随机数进行解密得到Server端的数据
加密算法：
|-对称加密：使用同一个密钥进行加解密，如：des、3des、aes
|-非对称加密：公钥加密，私钥解密，如：RSA
|-不可逆加密：MD5、SHA1

3、http请求报文和响应报文格式：
|-请求报文：请求方法,URI,HTTP版本协议
  |--请求行
  |--请求首部字段
  |--请求内容实体
|-响应报文：
  |--状态行：状态码、状态码原因、http版本信息
  |--响应首部字段
  |--响应内容实体


4、什么是Http协议无状态协议?怎么解决Http协议无状态协议?
|-HTTP是无状态的：不保留之前一切的请求或响应报文的信息；也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
|-HTTP是无连接的：限制每次连接只处理一个请求

5、一个完整http请求7个步骤：
|-建立TCP连接
|-Web浏览器向Web服务器发送请求行；如：GET /sample/hello.jsp HTTP/1.1
|-Web浏览器发送请求头
|-Web服务器应答；如：HTTP/1.1 200 OK
|-Web服务器发送应答头
|-Web服务器向浏览器发送数据
|-Web服务器关闭TCP连接

6、restful
|-restful其实就是一套编写接口的协议。
|-restful和非restful
  |--restful：给用户一个url，根据method不同在后端做不同的处理。
  |--no restful：给调用者很多url，每个url代表一个功能。
|-通过在url加上版本号，可达到兼容
|-常见状态码：
  |-1XX：通知
  |-2XX：成功
  |-3XX：重定向
  |-4XX：客户端错误
  |-5XX：服务器错误

7、接口的幂等性：
1、防止页面重复提交
|-使用token+redis机制
2、重试如何保证幂等；
|-对我们需要约束的字段创建唯一索引（比如：直接把上面的token做为唯一索引）

8、接口安全性：
1、使用客户端和服务端都能识别的token
2、对外提供接口的api如何保证安全；
|-使用MD5或SHA加密防篡改
非对称加密RSA：
|-客户端和服务器端：公钥加密，私钥解密
|-服务器端与服务器端：私钥加密，公钥解密

9、URI和URL的区别
|-URI可以是URN，也可以是URL，所以URL只是URI中的一种。所以我觉得研究URL和URI的区别，不如研究什么是URL和URN
|-URI用来标识一个资源、URL可以用来标识一个资源，还指明了这个资源的地址、URN通过名称来标识资源。

10、XSS：
在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式。比如：javascript能做的事它都能干。
|-类型
  |--反射型：写在URL中，通过浏览器直接“反射”给用户
  |--存储型：把黑客输入的恶意脚本存储在服务器的数据库中

11、CSRF:
CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。
比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。
通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。
Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。
这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。
当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。
但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。
等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。
解决方案：
1、过滤器判断请求头中的Referer的域名
2、token

12、Oauth2.0协议
|-生成授权链接，获取授权码code
|-根据授权码获取令牌AccessToken
|-根据令牌获取openId
|-使用openId获取用户信息
