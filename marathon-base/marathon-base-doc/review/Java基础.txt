JVM内存结构【hotspot jvm】：
|-程序计数器【PC寄存器】：保存的是程序当前执行的指令的地址
|-Java栈：栈帧组成，每个栈帧对应一个被调用的方法
  |--局部变量表
  |--操作数栈：程序中的所有计算过程都是在借助于操作数栈来完成的
  |--指向当前方法所属的类的运行时常量池的引用
  |--方法返回地址：方法执行完毕之后，要返回之前调用它的地方
  |--一些额外的附加信息
|-堆：存储对象以及数组，JDK7和JDK8不同之处在于堆【JDK6永久带；JDK7堆（JDK6永久带中的部分数据转移到了heap中，如：字面量、符号引用、类的静态变量，但永久代仍存在）；JDK8移除永久带，使用直接内存（又叫元空间）直接从操作系统中分配】
|-方法区：很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、运行时常量池以及编译器编译后的代码等【JDK换成直接内存了】
|-Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用
|-方法区是一种规范，而永久代是一种实现
|-JDK7、JDK8字符串常量池移到堆中

GC:
|-什么时候被移动到年老代呢？
  |--Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时（默认-XX:MaxTenuringThreshold=15岁，Parallel Scavenge中默认值为15，CMS中默认值为6，G1中默认值为15），就会被移动到年老代中
  |--当Eden+From/To要移动到From/To时，如果From/To没有足够内存空间分配，部分对象会分配到年老代。
|-判断哪些内存需要被回收
  |--引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收
  |--可达性分析法：当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
     |---可作为GC Roots：虚拟机栈、方法区的类静态属性、方法区中的常量、本地方法栈
|-垃圾收集算法
  |--标记-清除算法：效率和空间不足，会产生大量不连续的内存碎片，导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
  |--复制算法：复制算法是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。
     不过这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，
	 每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，
	 意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。
  |--标记-整理算法：不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
  |--分代收集算法：大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法
|-垃圾收集器【现在基本上都是使用组合收集器：如JDK7默认使用：Parallel Scavenge+Parallel Old】
  |--Serial收集器：
      |---是一个采用复制算法的单线程的收集器。
	  |---缺点：需要STW（Stop The World），停顿时间长；
	  |---优点：简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。
	  |---新生代、老年代使用串行回收
  |--ParNew收集器：
     |---其实就是Serial收集器的多线程版本，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
	 |---适用于多CPU的环境中，在单个CPU或两个CPU环境中都不能百分之百保证可以超越Serial收集器。
	 |---新生代并行，老年代串行
  |--Parallel Scavenge收集器：
     |---是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。
	 |---Parallel收集器+ 老年代串行
     |---它有一个-XX:+UseAdaptiveSizePolicy参数，用来打开自适应调节策略，就不需要手动指定新生代大小、Eden区和Survivor参数等参数了，虚拟机会根据当前系统的运行情况，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
  |--Serial Old收集器：
     |---Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法
  |--Parallel Old收集器：
     |---Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合
	 |---Parallel收集器+ 老年代并行
  |--CMS收集器：
     |---是以获取最短回收停顿时间为目标的收集器,是针对老年代进行回收的GC，基于标记 - 清除算法。
     |---包括四个步骤：
	     |----初始标记【1、标记GC Roots可达的老年代对象；2、遍历新生代对象，标记可达的老年代对象；3、速度很快，但需要STW】
	     |----并发标记
	          |-----对初始标记中标记的存活对象进行trace
	          |-----将在并发阶段新生代晋升到老年代的对象、直接在老年代分配的对象以及老年代引用关系发生变化的对象标记为dirty，避免在重新标记阶段扫描整个老年代。
	     |----重新标记【为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，需要STW】
	     |----并发清除【回收所有的垃圾对象】
	 |---优点：并发收集、低停顿；
	 |---缺点：产生大量空间碎片（使用了“标记—清除”算法）、无法处理浮动垃圾（并发清理阶段）、对CPU资源非常敏感（并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低）
	 |---参数配置：-XX:+UseConcMarkSweepGC
  |--G1收集器：
     |---为解决CMS算法产生空间碎片和其它一系列的问题缺陷
	 |---G1的新生代收集跟ParNew类似；G1的老年代收集跟CMS类似
     |---参数配置：-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200【最大暂停时间】
	 |---取消了新生代，老年代的物理空间划分，但还保留有新生代和老年代的概念
	 |---G1算法将堆划分为若干个区域（Eden、Survivor、Old、Humongous），它仍然属于分代收集器。
	 |---G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了
	 |---G1划分了一个Humongous（巨大的）区，它用来专门存放巨型对象。
	 |---young gc：触发机制和之前的young gc差不多
	 |---mixed gc：除了回收整个young region，还会回收一部分的old region。当老年代大小占整个堆大小百分比达到该阈值（-XX:InitiatingHeapOccupancyPercent）时，会触发一次mixed gc。mixed gc的执行过程有点类似cms
	 |---full gc：当老年代没有足够空间分配时，会出发一次full gc
|-JDK默认垃圾收集器【查看JDK使用哪种收集器：java -XX:+PrintCommandLineFlags -version】
  |--jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
  |--jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
  |--jdk1.9——jdk11 默认垃圾收集器G1

类加载:
|-类加载过程
  |--加载：class字节码-类加载器->Class对象
  |--连接：
     |---验证：验证加载的类信息符合JVM规范
	 |---准备：为类变量分配内存，并设置默认初始值
	 |---解析：将类的二进制数据中的符号引用替换为直接引用
  |--初始化：主要是对类变量进行初始化
|-类变量指定初始值有两种：
  |--声明类变量时指定初始值
  |--使用静态代码块指定初始值
|-初始化步骤
  |--如果该类还没有被加载和连接，则先加载并连接该类
  |--如果该类的直接父类还没有被初始化，则先初始化其直接父类。所以JVM最先初始化的总是Object类
  |--如果类中有初始化语句，则系统依次执行这些初始化语句
|-初始化时机
  |--创建类的实例
  |--调用某个类的类方法
  |--访问某个类或接口的类变量
  |--使用反射创建某个类或接口的Class对象。
  |--初始化某个类的子类
  |--特例：
     class Test{
		static{
			System.out.println("Test 静态代码块");//这句不会被打印
		}
		static final String json = "json string";//json被称为”宏变量“
		public static void main(String[] args){
			System.out.println(Test.json);//在编译时，Test.json就已经被替换成"json string"了，所以不会导致初始化Test类
		}
	 }
     class Test{
		static{
			System.out.println("Test 静态代码块");//这句会被打印
		}
		static final String json = System.currentTimeMillis()+"";
		public static void main(String[] args){
			System.out.println(Test.json);//在编译时，Test.json还不能确定下来，所以会导致初始化Test类
		}
	 }
     public class ClassTest{
		public static void main(String[] args){
			ClassLoader cl = ClassLoader.getSystemClassLoader();
			cl.loadClass("Test");//不会导致初始化Test类
			Class.forName("Test");//会导致初始化Test类
		}
	 }
|-类加载器
  |--Bootstrap ClassLoader：引导加载器（负责加载Java的核心类%JAVA_HOME%/jre/rt.jar）
  |--Extension ClassLoader：扩展类加载器（负责加载JRE的扩展目录%JAVA_HOME%/jre/lib/ext）
  |--System ClassLoader：系统类加载器（负责classpath下的JAR类包和类路径）
  |--自定义类加载器：
     |---extends ClassLoader:loadClass(String name, boolean resolve);findClass(String name);
|-类加载机制
  |--全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class都有该类加载器负责载入
  |--双亲委派模型：
     |---每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成这个加载，子类尝试自己加载。
	 |---优点：1、避免同一个类被多次加载；2、每个加载器只能加载自己范围内的类；
	 |---为什么需要双亲委派模型？
	 黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。
	 比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。
	 并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，
	 那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。
	 而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。
	 或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?
	 确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。
  |--缓存机制：缓存所有被加载过的Class，当程序需要使用某个Class时，类加载器先从缓存中查找。

HashMap的原理：
|-采用位桶+链表+红黑树实现
|-数组（Node<key,value> implements Map.Entry<key,value>）默认初始化大小为16，当达到16*0.75（负载因子）会进行扩容2倍，当链表的长度大于8时，采用红黑树(TreeMap)，提高查找效率
|-当put(key,value)，先计算hash(key)，找到数组索引，在链表的后面插入一个节点。
|-哈希碰撞:就是hash(key)相等，然后使用链表解决，链表长度大于8后，使用红黑树解决。因为如果最坏的情况所有的Node都落在一个桶中，这样hashmap就退化成了一个链表——查找时间从O(1)到O(n)，使用红黑树查找时间O(logn)。

HashMap:
|-数组+单向链表+红黑树
|-键值允许为null
|-线程不安全
|-默认的初始大小为16,扩容2n
|-Node<K,V>[] table
HashTable:
|-数组+单向链表
|-键值不允许为null
|-线程安全【全表锁，所有操作竞争一把锁，性能非常差】
|-默认的初始大小为11,扩容2n+1
ConcurrentHashMap:
|-数组+单向链表+红黑树
|-键值不允许为null
|-线程安全【使用锁分段技术：每个数据段配一把锁】
|-默认的初始大小为16,扩容2n
|-ConcurrentHashMap不会抛出ConcurrentModificationException
|-Node<K,V>[] table
线程安全的Map：
|-Map<String, String> hashtable = new Hashtable<String, String>();
|-Map<String, String> synchronizedHashMap = Collections.synchronizedMap(new HashMap<String, String>());
|-Map<String, String> concurrentHashMap = new ConcurrentHashMap<String, String>();

Lock和synchronized区别：
|-Lock不会自动释放锁；synchronized会自动释放锁;
|-Lock是一个接口，而synchronized是Java中的关键字
|-Lock可以让等待锁的线程响应中断，而synchronized却不行
|-Lock可以知道有没有成功获取锁，而synchronized却无法办到
|-使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生
|-锁概念：
  |--可重入锁（Lock、synchronized）：例如当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，不必重新去申请锁。
  |--可中断锁（Lock）：如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
  |--公平锁（Lock可以设置成公平锁，ReentrantLock lock = new ReentrantLock(true);）：以请求锁的顺序来获取锁，等待时间最久的线程（最先请求的线程）会获得该锁。
  |--读写锁（ReentrantReadWriteLock）：1、获得读锁后，其它线程可获得读锁而不能获取写锁；2、获得写锁后，其它线程既不能获得读锁也不能获得写锁。

创建线程
|-匿名内部类
FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>(){
	@Override
	public Integer call() throws Exception {
		for (int i = 0; i < 3; i++) {
			System.out.println(i);
		}
		return 1;
	}
});
|-Lambda表达式
FutureTask<Integer> task = new FutureTask<>(() -> {
	for (int i = 0; i < 3; i++) {
		System.out.println(i);
	}
	return 1;
});
new Thread(task).start();
|-写一个多线程抢票
public class Ticket implements Runnable {
    public int number = 50;
    public Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (number <= 0) {
                    break;
                }
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName() + "抢到第" + number + "张票");
                number--;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
public class TicketTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        for (int i = 1; i <= 3; i++) {
            new Thread(ticket).start();
        }
    }
}

Volatile:
|-可见性和禁止重排序
|-用来确保将变量的更新操作通知到其他线程。volatile变量是一种比sychronized关键字更轻量级的同步机制。当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
|-当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。
  而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。
|-例子：
public class VolatileTest extends Thread {

    boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
    }

    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println("stope" + vt.i);
    }
}
执行结果：程序永远不会跳出循环了。
原因：首先主线程会把flag与i从‘主内存’中拷贝一份到自己的工作内存中，因为vt.flag = true;只是更新了主内存中的flag值，而主线程读的又是自己的工作内存，所以flag一直都是false。
解决：volatile boolean flag = false;

ThreadLocal:
|-为每一个线程维护一份独立的变量副本
|-线程同步机制采取了时间换空间的方式，访问串行化，对象共享化；而ThreadLocal采取了空间换时间的方式，访问并行化，对象独享化。
|-ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。ThreadLocal 并不解决线程间共享数据的问题。
|-适用场景：1、每个线程需要有自己单独的实例；2、实例需要在多个方法中共享，但不希望被多线程共享
|-ThreadLocal 维护一个ThreadLocalMap，键是 Thread，值是它在该 Thread 内的实例。
|-ThreadLocalMap中的Entry extends WeakReference<ThreadLocal<?>>【弱引用】，使用弱引用的原因在于，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免线程结束时， ThreadLocal 不能被回收而造成的内存泄漏的问题。
指令重排序
|-编译器和处理器为了提高程序的运行性能，对指令进行重新排序。会遵守数据依赖性（as-if-serial），编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序
|-int a = 10;int b = 20;可能第二条语句先执行，因为在单线程情况下不影响运行结果。
写开放的API接口时是如何保证数据的安全性的？
|-请求来源(身份)是否合法？
|-请求参数被篡改？
|-请求的唯一性(不可复制)，防止请求被恶意攻击

NIO:JDK1.4
|-NIO中的重要概念 通道、缓冲区、选择器（Selectors）
|-与传统IO的区别：
  |--IO面向流，NIO面向缓冲区；新IO采用内存映射文件的方式处理输入/输出，将文件或文件的一段区域映射到内存中。
  |--IO属于阻塞IO，NIO属于非阻塞IO；
     |---阻塞：当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
	 |---非阻塞：线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）
  |--选择器:用于监听多个通道的事件

@Resource和@Autowired区别：
|-@Autowired是Spring提供的注解；@Resource由J2EE提供，需要导入包javax.annotation.Resource；
|-@Autowired是byType，如果想使用byName可以结合@Qualifier注解一起使用；@Resource默认是byName，@Resource有两个重要的属性：name和type
|-一个接口多个实现类的情况：@Autowired @Qualifier("imgDataDao")或@Resource DataDao imgDataDao;或@Resource(name="imgDataDao")DataDao dataDao;
@Resource装配顺序：
①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。
②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。
③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。
④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。


swagger-models举例改源码，然后重新打成jar：
|-下载swagger-models-1.5.20.jar、swagger-models-1.5.20-sources.jar、swagger-models-1.5.20.pom.xml
|-解压swagger-models-1.5.20.jar、swagger-models-1.5.20-sources.jar
|-创建一个Maven工程，然后将swagger-models-1.5.20.pom.xml中的内容全部拷贝到pom.xml中的内容全部拷贝到pom
|-把解压后swagger-models-1.5.20-sources.jar中的io整个目录拷贝到项目中的java目录下
|-把解压后swagger-models-1.5.20.jar中的META-INF整个目录拷贝到项目中的resource目录下
|-修改源码
|-mvn clean package -U -Dmaven.test.skip=true

看源码：
Spring IOC、AOP、MVC原理及源码
Mybatis源码
设计模式【装饰模式】：IO
//基础接口
public interface Component {

    public void biu();
}
//具体实现类
public class ConcretComponent implements Component {

    public void biu() {
        System.out.println("biubiubiu");
    }
}
//装饰类
public class Decorator implements Component {

    public Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    public void biu() {
        this.component.biu();
    }
}
//具体装饰类
public class ConcreteDecorator extends Decorator {

    public ConcreteDecorator(Component component) {
        super(component);
    }

    public void biu() {
        System.out.println("ready?go!");
        this.component.biu();
    }
}
//测试
Component component = new ConcreteDecorator(new ConcretComponent());
component.biu();

SpringBoot自动配置原理：
@EnableAutoConfiguration
@Import(AutoConfigurationImportSelector.class)
public String[] selectImports(AnnotationMetadata annotationMetadata){
    AutoConfigurationEntry autoConfigurationEntry =
    getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
}
protected AutoConfigurationEntry getAutoConfigurationEntry(
			AutoConfigurationMetadata autoConfigurationMetadata,
			AnnotationMetadata annotationMetadata) {
    List<String> configurations = getCandidateConfigurations(annotationMetadata,attributes);
}
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata,
			AnnotationAttributes attributes) {
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
                 getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
}
//META-INF/spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
把这个文件的urls拿到之后并把这些urls每一个遍历，最终把这些文件整成一个properties对象

抽象类和接口的区别：
1、成员区别：
|-抽象类：
  |--成员变量：变量、常量
  |--构造方法：有
  |--成员方法：抽象、非抽象
|-接口：
  |--成员变量：常量
  |--构造方法：无
  |--成员方法：抽象
2、关系区别：
|-类与类：单继承
|-类与接口：单实现、多实现
|-接口与接口：多继承
3、设计理念：
抽象类：体现的是"is a"的关系，定义的是共性功能
接口：体现的是"like a"的关系，定义的是扩展功能


ThreadPoolAbstractExecutorService.newCachedThreaPool




